<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Calibration Simulation</title>
    <button id="compute-button">Refine Measurments 1x</button>
    <button id="compute-1k-button">1,000x</button>
    <button id="compute-10k-button">10,000x</button>
    <button id="compute-end-button">End</button>
    <style>
        body {
            margin: 0;
        }
    </style>
    
</head>
<body id= "mainBody">

<---click this button to see the simulation find the corners

<div id = "views">

</div>

<script>

//This is the inital guess for how big the machine is. These numbers are wrong intensionally
const initialWidth = 3048 + 12;
const initialHeight = 2200 - 14;


//These are the true corners of the machine that we want to solve for (only used for simulated measurments)
const trueTLX = -0.6948090610228441;
const trueTLY = 2131.275233532367;
const trueTRX = 3034.4072793128926;
const trueTRY = 2127.1780972406527;
const trueBLX = 0;
const trueBLY = 0;
const trueBRX = 3034.960970894897;
const trueBRY = 0;


/**------------------------------------Intro------------------------------------
*
*   If you are reading this code to understand it then I would recommend starting
*  at the bottom of the page and working your way up. The code is written in a
* functional style so the function definitions are at the top and the code that
* actually runs is at the bottom. It was also written quickly and modified a lot
* so it is not very clean. I apologize for that.
*
*------------------------------------------------------------------------------
*/


/**
 * Simulates a measurement at a given location with random and constant errors.
 * @param {number} x - The x-coordinate of the location to measure.
 * @param {number} y - The y-coordinate of the location to measure.
 * @param {number} randomError - The maximum amount of random error to add to the measurement.
 * @param {number} constantError - The constant error to add to the measurement.
 * @returns {Object} - An object containing the simulated measurements at the given location.
 */
function takeSimulatedMeasurement(x,y,randomError, constantError){
    const tl = distanceBetweenPoints(trueTLX, trueTLY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    const tr = distanceBetweenPoints(trueTRX, trueTRY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    const bl = distanceBetweenPoints(trueBLX, trueBLY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    const br = distanceBetweenPoints(trueBRX, trueBRY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    return {tl: tl, tr: tr, bl: bl, br: br};
}

/**
 * Computes the distance between two points.
 * @param {number} a - The x-coordinate of the first point.
 * @param {number} b - The y-coordinate of the first point.
 * @param {number} c - The x-coordinate of the second point.
 * @param {number} d - The y-coordinate of the second point.
 * @returns {number} - The distance between the two points.
 */
function distanceBetweenPoints(a, b, c, d) {
  var dx = c - a;
  var dy = d - b;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Computes the end point of a line based on its starting point, angle, and length.
 * @param {number} startX - The x-coordinate of the line's starting point.
 * @param {number} startY - The y-coordinate of the line's starting point.
 * @param {number} angle - The angle of the line in radians.
 * @param {number} length - The length of the line.
 * @returns {Object} - An object containing the x and y coordinates of the line's end point.
 */
function getEndPoint(startX, startY, angle, length) {
  var endX = startX + length * Math.cos(angle);
  var endY = startY + length * Math.sin(angle);
  return { x: endX, y: endY };
}

/**
 * Computes how close all of the line end points are to each other.
 * @param {Object} line1 - The first line to compare.
 * @param {Object} line2 - The second line to compare.
 * @param {Object} line3 - The third line to compare.
 * @param {Object} line4 - The fourth line to compare.
 * @returns {number} - The fitness value, which is the average distance between all line end points.
 */
function computeEndpointFitness(line1, line2, line3, line4){

    const a = distanceBetweenPoints(line1.xEnd, line1.yEnd, line2.xEnd, line2.yEnd);
    const b = distanceBetweenPoints(line1.xEnd, line1.yEnd, line3.xEnd, line3.yEnd);
    const c = distanceBetweenPoints(line1.xEnd, line1.yEnd, line4.xEnd, line4.yEnd);
    const d = distanceBetweenPoints(line2.xEnd, line2.yEnd, line3.xEnd, line3.yEnd);
    const e = distanceBetweenPoints(line2.xEnd, line2.yEnd, line4.xEnd, line4.yEnd);
    const f = distanceBetweenPoints(line3.xEnd, line3.yEnd, line4.xEnd, line4.yEnd);

    const fitness = (a+b+c+d+e+f)/6;

    return fitness;
}

/**
 * Computes the end point of a line based on its starting point, angle, and length.
 * @param {Object} line - The line to compute the end point for.
 * @returns {Object} - The line with the end point added.
 */
function computeLineEndPoint(line){
    const end = getEndPoint(line.xBegin, line.yBegin, line.theta, line.length);
    line.xEnd = end.x;
    line.yEnd = end.y;
    return line;
}

/**
 * Walks the four lines in the given set, adjusting their endpoints to minimize the distance between them.
 * @param {Object} tlLine - The top-left line in the set.
 * @param {Object} trLine - The top-right line in the set.
 * @param {Object} blLine - The bottom-left line in the set.
 * @param {Object} brLine - The bottom-right line in the set.
 * @param {number} stepSize - The amount to adjust the angle of each line by on each iteration.
 * @returns {Object} - An object containing the final positions of each line.
 */
function walkLines(tlLine, trLine, blLine, brLine, stepSize) {
  let changeMade = true;
  let bestFitness = computeEndpointFitness(tlLine, trLine, blLine, brLine);

  while (changeMade) {
    changeMade = false;

    const lines = [tlLine, trLine, blLine, brLine];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      for (let direction of [-1, 1]) {
        const newLine = computeLineEndPoint({
          xBegin: line.xBegin,
          yBegin: line.yBegin,
          theta: line.theta + direction * stepSize,
          length: line.length
        });

        const newFitness = computeEndpointFitness(
          i === 0 ? newLine : tlLine,
          i === 1 ? newLine : trLine,
          i === 2 ? newLine : blLine,
          i === 3 ? newLine : brLine
        );

        if (newFitness < bestFitness) {
          lines[i] = newLine;
          bestFitness = newFitness;
          changeMade = true;
        }
      }
    }

    tlLine = lines[0];
    trLine = lines[1];
    blLine = lines[2];
    brLine = lines[3];
  }

  return { tlLine, trLine, blLine, brLine };
}

/**
 * Computes the fitness of a set of lines based on how close their endpoints are to each other.
 * @param {Object} measurement - An object containing the initial theta values and lengths for each line.
 * @param {Object} individual - An object containing the x and y coordinates for each line's starting point.
 * @returns {Object} - An object containing the fitness value and the final positions of each line.
 */
function magneticallyAttractedLinesFitness(measurement, individual){

    //These set the inital conditions for theta. They don't really mater, they just have to kinda point to the middle of the frame.
    if(measurement.tlTheta == undefined){
        measurement.tlTheta = -.3;
    }
    if(measurement.trTheta == undefined){
        measurement.trTheta = 3.5;
    }
    if(measurement.blTheta == undefined){
        measurement.blTheta = .5;
    }
    if(measurement.brTheta == undefined){
        measurement.brTheta = 2.6;
    }


    //Define the four lines with starting points and lengths
    var tlLine = computeLineEndPoint({xBegin: individual.tl.x, yBegin: individual.tl.y, theta: measurement.tlTheta, length: measurement.tl});
    var trLine = computeLineEndPoint({xBegin: individual.tr.x, yBegin: individual.tr.y, theta: measurement.trTheta, length: measurement.tr});
    var blLine = computeLineEndPoint({xBegin: individual.bl.x, yBegin: individual.bl.y, theta: measurement.blTheta, length: measurement.bl});
    var brLine = computeLineEndPoint({xBegin: individual.br.x, yBegin: individual.br.y, theta: measurement.brTheta, length: measurement.br});

    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .1);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .01);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .0001);
    //var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .00001);
    //var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .000001);
    //var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .0000001);
    //var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .00000001);

    measurement.tlTheta = tlLine.theta;
    measurement.trTheta = trLine.theta;
    measurement.blTheta = blLine.theta;
    measurement.brTheta = brLine.theta;

    //Compute the final fitness
    const finalFitness = computeEndpointFitness(tlLine, trLine, blLine, brLine);

    //Compute the tension in the two upper belts
    const { TL, TR } = calculateTensions(tlLine.xEnd, tlLine.yEnd, individual);
    measurement.TLtension = TL;
    measurement.TRtension = TR;


    return {fitness: finalFitness, lines: {tlLine: tlLine, trLine: trLine, blLine: blLine, brLine: brLine}};
}

/**
 * Computes the distance of one line's end point from the center of mass of the other three lines.
 * @param {Object} lineToCompare - The line to compute the distance for.
 * @param {Object} line2 - The second line to use in computing the center of mass.
 * @param {Object} line3 - The third line to use in computing the center of mass.
 * @param {Object} line4 - The fourth line to use in computing the center of mass.
 * @returns {Object} - An object containing the x and y distances from the center of mass.
 */
function computeDistanceFromCenterOfMass(lineToCompare, line2, line3, line4){

    //Compute the center of mass
    const x = (line2.xEnd + line3.xEnd + line4.xEnd)/3;
    const y = (line2.yEnd + line3.yEnd + line4.yEnd)/3;

    return {x: lineToCompare.xEnd - x, y: lineToCompare.yEnd - y};
}

/**
 * Computes the distances from the center of mass for four lines and converts them into the relevant variables that we can tweak.
 * @param {Object} lines - An object containing four lines to compute the distances from the center of mass for.
 * @returns {Object} - An object containing the distances from the center of mass for tlX, tlY, trX, trY, and brX.
 */
function generateTweaks(lines){
    //We care about the distances for tlX, tlY, trX, trY, brX

    const tlX = computeDistanceFromCenterOfMass(lines.tlLine, lines.trLine, lines.blLine, lines.brLine).x;
    const tlY = computeDistanceFromCenterOfMass(lines.tlLine, lines.trLine, lines.blLine, lines.brLine).y;
    const trX = computeDistanceFromCenterOfMass(lines.trLine, lines.tlLine, lines.blLine, lines.brLine).x;
    const trY = computeDistanceFromCenterOfMass(lines.trLine, lines.tlLine, lines.blLine, lines.brLine).y;
    const brX = computeDistanceFromCenterOfMass(lines.brLine, lines.tlLine, lines.trLine, lines.blLine).x;

    return {tlX: tlX, tly: tlY, trX: trX, trY: trY, brX: brX};
}

/**
 * Computes all of the tweaks and summarizes them to move the guess furthest from the center of mass of the lines.
 * @param {Array} lines - An array of lines to compute the tweaks for.
 * @param {Object} lastGuess - The last guess made by the algorithm.
 * @returns {Object} - The updated guess with the furthest tweaks applied.
 */
function computeFurthestFromCenterOfMass(lines, lastGuess){

    var tlX = 0;
    var tlY = 0;
    var trX = 0;
    var trY = 0;
    var brX = 0;

    lines.forEach(line => {
        const tweaks = generateTweaks(line);
        
        tlX = tlX + tweaks.tlX;
        tlY = tlY + tweaks.tly;
        trX = trX + tweaks.trX;
        trY = trY + tweaks.trY;
        brX = brX + tweaks.brX;

    })

    tlX = tlX/lines.length;
    tlY = tlY/lines.length;
    trX = trX/lines.length;
    trY = trY/lines.length;
    brX = brX/lines.length;

    const maxError = Math.max(
        Math.abs(tlX),
        Math.abs(tlY),
        Math.abs(trX),
        Math.abs(trY),
        Math.abs(brX)
    );


    var divisor = -10;
    if(maxError == Math.abs(tlX)){
        //console.log("Move tlY by: " + tlY/divisor);
        lastGuess.tl.x = lastGuess.tl.x + tlX/divisor;
    }
    if(maxError == Math.abs(tlY)){
        //console.log("Move tlY by: " + tlY/divisor);
        lastGuess.tl.y = lastGuess.tl.y + tlY/divisor;
    }
    else if(maxError == Math.abs(trX)){
        //console.log("Move trX by: " + trX/divisor);
        lastGuess.tr.x = lastGuess.tr.x + trX/divisor;
    }
    else if(maxError == Math.abs(trY)){
        //console.log("Move trY by: " + trY/divisor);
        lastGuess.tr.y = lastGuess.tr.y + trY/divisor;
    }
    else if(maxError == Math.abs(brX)){
        //console.log("Move brX by: " + brX/divisor);
        lastGuess.br.x = lastGuess.br.x + brX/divisor;
    }
    
    return lastGuess;
}

/**
 * Computes the fitness of a guess for a set of measurements by comparing the guess to magnetically attracted lines.
 * @param {Array} measurements - An array of measurements to compare the guess to.
 * @param {Object} lastGuess - The last guess made by the algorithm.
 * @returns {Object} - An object containing the fitness of the guess and the lines used to calculate the fitness.
 */
function computeLinesFitness(measurements, lastGuess){
    var fitnesses = [];
    var allLines = [];
    
    //Check each of the measurements against the guess
    measurements.forEach(measurement => {
        const {fitness, lines} = magneticallyAttractedLinesFitness(measurement, lastGuess);
        fitnesses.push(fitness);
        allLines.push(lines);
        
    });
    //print all of the fitnesses next to each measurement in red color and update canvas in real time
    printFitnesses(measurements, lastGuess);


    
    //draw all the lines:
    for (var i = 0; i < allLines.length; i++) {
        //drawLines(allLines[i].tlLine, allLines[i].trLine, allLines[i].blLine, allLines[i].brLine, lastGuess);
    }
    //Computes the average fitness of all of the measurements
    const fitness = calculateAverage(fitnesses);

    //console.log(fitnesses);

    //Here is where we need to do the calculation of which corner is the worst and which direction to move it
    lastGuess = computeFurthestFromCenterOfMass(allLines, lastGuess);
    lastGuess.fitness = fitness;

    return lastGuess;
}


function calculateTensions(x, y, guess) {
    let Xtl = guess.tl.x;
    let Ytl = guess.tl.y;
    let Xtr = guess.tr.x;
    let Ytr = guess.tr.y;
    let Xbl = guess.bl.x;
    let Ybl = guess.bl.y;
    let Xbr = guess.br.x;
    let Ybr = guess.br.y;

    let BL = 140; //say tension in bottom belts is ~14kg
    let BR = 140; 

    let mass = 5.0;
    const G_CONSTANT = 9.80665;
    let alpha = 0.262;
    let TL, TR;
  
    let A, C, sinD, cosD, sinE, cosE;
    let Fx, Fy;

    A = (Xtl - x) / (Ytl - y);
    C = (Xtr - x) / (Ytr - y);
    A = Math.abs(A);
    C = Math.abs(C);
    sinD = x / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    cosD = y / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    sinE = Math.abs(Xbr - x) / Math.sqrt(Math.pow(Xbr - x, 2) + Math.pow(y, 2));
    cosE = y / Math.sqrt(Math.pow(Xbr - x, 2) + Math.pow(y, 2));

    Fx = BR * sinE - BL * sinD;
    Fy = BR * cosE + BL * cosD + mass * G_CONSTANT * Math.cos(alpha);
     //console.log(`Fx = ${Fx.toFixed(1)}, Fy = ${Fy.toFixed(1)}`);

    let TLy = (Fx + C * Fy) / (A + C);
    let TRy = Fy - TLy;
    let TRx = C * (Fy - TLy);
    let TLx = A * TLy;

     //console.log(`TLy = ${TLy.toFixed(1)}, TRy = ${TRy.toFixed(1)}, TRx = ${TRx.toFixed(1)}, TLx = ${TLx.toFixed(1)}`);

    TL = Math.sqrt(Math.pow(TLx, 2) + Math.pow(TLy, 2));
    TR = Math.sqrt(Math.pow(TRx, 2) + Math.pow(TRy, 2));
    //console.log(`TL = ${TL.toFixed(1)}, TR = ${TR.toFixed(1)}`);
    return { TL, TR };
}

/**
 * Flips the y-coordinate of a point to account for the canvas having y at the top.
 * @param {number} y - The y-coordinate to flip.
 * @returns {number} - The flipped y-coordinate.
 */
function flipY(y) {
  var canvas = document.getElementById("CursorLayer");
  return canvas.height - y;
}

function changeStrokeStyle(inputValue) {
  const green = [0, 128, 0]; // RGB values for green
  const red = [255, 0, 0]; // RGB values for red
  const range = 60 - 20; // Range of input values
  const increment = (red.map((value, index) => value - green[index])).map(value => value / range); // Increment for each RGB value

  const color = green.map((value, index) => Math.round(value + increment[index] * (inputValue - 20))); // Calculate the color based on the input value

  const canvas = document.getElementById("CursorLayer");
  const ctx = canvas.getContext("2d");

  ctx.strokeStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`; // Set the strokeStyle to the calculated color
}

/**
 * Draws four lines on a canvas element and adds a circle at the end of each line.
 * @param {Object} line1 - An object containing the x and y coordinates of the beginning and end of the first line.
 * @param {Object} line2 - An object containing the x and y coordinates of the beginning and end of the second line.
 * @param {Object} line3 - An object containing the x and y coordinates of the beginning and end of the third line.
 * @param {Object} line4 - An object containing the x and y coordinates of the beginning and end of the fourth line.
 * @returns {void}
 */
function drawLines(line1, line2, line3, line4, guess) {

    //Compute the tensions in the upper two belts
    //const { TL, TR } = calculateTensions(line1.xEnd, line1.yEnd, guess); //This assumes the ends are in the same place which they aren't at first

    var canvas = document.getElementById("CursorLayer");
    var ctx = canvas.getContext("2d");

    // Set the stroke color to a lighter grey
    ctx.strokeStyle = "#999";

    // Draw the four lines
    ctx.setLineDash([5, 5]);

    //Top left line
    ctx.beginPath();
    ctx.moveTo(line1.xBegin / 4, flipY(line1.yBegin / 4));
    ctx.lineTo(line1.xEnd / 4, flipY(line1.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line1.xEnd / 4, flipY(line1.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    //Top right line
    ctx.beginPath();
    ctx.moveTo(line2.xBegin / 4, flipY(line2.yBegin / 4));
    ctx.lineTo(line2.xEnd / 4, flipY(line2.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line2.xEnd / 4, flipY(line2.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line3.xBegin / 4, flipY(line3.yBegin / 4));
    ctx.lineTo(line3.xEnd / 4, flipY(line3.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line3.xEnd / 4, flipY(line3.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line4.xBegin / 4, flipY(line4.yBegin / 4));
    ctx.lineTo(line4.xEnd / 4, flipY(line4.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line4.xEnd / 4, flipY(line4.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    
  
    // ctx.fillText("TL: " + TL.toFixed(2), line1.xEnd / 4, flipY(line1.yEnd / 4) + 10);
    // ctx.fillText("TR: " + TR.toFixed(2), line1.xEnd / 4, flipY(line1.yEnd / 4) + 20);
    
}
//print all of the fitnesses next to each measurement in red color

function printFitnesses(measurements, guess){
    var canvas = document.getElementById("CursorLayer");
    var ctx = canvas.getContext("2d");
    ctx.fillStyle = "#FF0000";
    ctx.font = "14px Arial";
    var i = 0;
    measurements.forEach(measurement => {
        const {fitness, lines} = magneticallyAttractedLinesFitness(measurement, guess);
        i++;
        ctx.fillText(fitness.toFixed(4), (i/10)*70,(i%10)*30);
    });

}


/**
 * Calculates the average of an array of numbers.
 * @param {number[]} array - The array of numbers to calculate the average of.
 * @returns {number} - The average of the array.
 */
function calculateAverage(array) {
    var total = 0;
    var count = 0;

    array.forEach(function(item, index) {
        total += Math.abs(item);
        count++;
    });

    return total / count;
}

/**
 * Prints the difference between the real values and the computed values for the corners. Only useful when using simulated
 * measurements.
 * @param {Object} guess - An object containing the x and y coordinates of the top left, top right, bottom left, and bottom right corners of a trapazoid.
 * @returns {void}
 */
function printResults(guess){
    // console.log("tlX error: " + (guess.tl.x - trueTLX) + "mm at: " + guess.tl.x);
    // console.log("tlY error: " + (guess.tl.y - trueTLY) + "mm at: " + guess.tl.y);
    // console.log("trX error: " + (guess.tr.x - trueTRX) + "mm at: " + guess.tr.x);
    // console.log("trY error: " + (guess.tr.y - trueTRY) + "mm at: " + guess.tr.y);
    // console.log("brX error: " + (guess.br.x - trueBRX) + "mm at: " + guess.br.x);

    console.log("(" + guess.tl.x + ", " + guess.tl.y + "), (" + guess.tr.x + ", " + guess.tr.y + ")\n (" + guess.bl.x + ", " + guess.bl.y + "), (" + guess.br.x + ", " + guess.br.y + ")"); 

}

/**
 * Projects the measurements to the plane of the machine. This is needed
 * because the belts are not parallel to the surface of the machine.
 * @param {Object} measurement - An object containing the measurements
 * @returns {Object} - An object containing the projected measurements
 */
function projectMeasurement(measurement){
    const tlZ = 116;
    const trZ = 69;
    const blZ = 47;
    const brZ = 89;
    //back correction for arms lengts 
    const armLength = 0;// 123.4;
    const tl = Math.sqrt(Math.pow(measurement.tl - armLength, 2) - Math.pow(tlZ,2)) + armLength;
    const tr = Math.sqrt(Math.pow(measurement.tr - armLength, 2) - Math.pow(trZ,2)) + armLength;
    const bl = Math.sqrt(Math.pow(measurement.bl - armLength, 2) - Math.pow(blZ,2)) + armLength;
    const br = Math.sqrt(Math.pow(measurement.br - armLength, 2) - Math.pow(brZ,2)) + armLength;

    return {tl: tl, tr: tr, bl: bl, br: br};
}

/**
 * Projects an array of measurements to the plane of the machine to account for the fact that the start and end point are not in the same plane.
 * @param {Object[]} measurements - An array of objects containing the measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 * @returns {Object[]} - An array of objects containing the projected measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 */
function projectMeasurements(measurements){
    var projectedMeasurements = [];

    measurements.forEach(measurement => {
        projectedMeasurements.push(projectMeasurement(measurement));
    });

    return projectedMeasurements;
}

/**
 * Adds a constant to each measurement in an array of measurements.
 * @param {Object[]} measurements - An array of objects containing the measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 * @param {number} offset - The constant to add to each measurement.
 * @returns {Object[]} - An array of objects containing the updated measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 */
function offsetMeasurements(measurements, offset) {
    const newMeasurements = measurements.map(measurement => {
        return {
            tl: measurement.tl + offset,
            tr: measurement.tr + offset,
            bl: measurement.bl + offset,
            br: measurement.br + offset
        };
    });

    return newMeasurements;
}

/**
 * Scales each measurement in an array of measurements by a constant. 
 * @param {Object[]} measurements - An array of objects containing the measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 * @param {number} scale - The constant to multiply each measurement by.
 * @returns {Object[]} - An array of objects containing the updated measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 */
function scaleMeasurements(measurements, scale) {
    const newMeasurements = measurements.map(measurement => {
        return {
            tl: measurement.tl * scale,
            tr: measurement.tr * scale,
            bl: measurement.bl,  // * scale,
            br: measurement.br,  // * scale
        };
    });

    return newMeasurements;
}

function scaleMeasurementsBasedOnTension(measurements, guess) {



    const bottomTension = 140; 
    const spring = guess; //0.01; // mm/N

    //const scaleRange = maxScale - minScale;
    //const tensionRange = maxTension - minTension;
    

    const newMeasurements = measurements.map(measurement => {

        const stretchTL = measurement.TLtension*spring;
        const stretchTR = measurement.TRtension*spring;
        const stretchBL = bottomTension*spring;
        const stretchBR = bottomTension*spring;
        
        
        //const tensionAdjustedTLScale = (1 - ((measurement.TLtension - minTension) / tensionRange)) * scaleRange + minScale;
        //const tensionAdjustedTRScale = (1 - ((measurement.TRtension - minTension) / tensionRange)) * scaleRange + minScale;

        console.log( "stretchTL = " + stretchTL + "  stretchTR = " + stretchTR);

        return {
            tl: measurement.tl  + stretchTL,
            tr: measurement.tr  + stretchTR,
            bl: measurement.bl  + stretchBL,  // * scale,
            br: measurement.br  + stretchBR,  // * scale
        };
    });

    return newMeasurements;
}


function findMaxFitness(initialGuess, measurements) {
    var maxFitness = -1;
    var newFitness = 0;
    var stagnantCounter = 0;

    while (stagnantCounter < 30) {
        maxFitness = newFitness;

        var maxFitnessThisRun = 0;
        //Run 1,000 steps
        for (let i = 0; i < 100; i++) {
            clearCanvas();
            initialGuess = computeLinesFitness(measurements, initialGuess);
            maxFitnessThisRun = Math.max(1 / initialGuess.fitness, maxFitnessThisRun);
        }

        newFitness = maxFitnessThisRun;
        console.log("Fitness: " + newFitness);

        if (stagnantCounter > 1) {
            console.log("Stagnant Counter: " + stagnantCounter);
        }

        if (newFitness <= maxFitness) {
            stagnantCounter++;
        } else {
            stagnantCounter = 0;
        }
    }

    console.log("Maxfitness: " + maxFitness);
    console.log("NewFitness: " + newFitness);

    return initialGuess;
}




//Creates the canvas on which the pattern will be drawn
var canvas = document.createElement('canvas');
canvas.id     = "CursorLayer";
canvas.width  = 1000;
canvas.height = 600;
canvas.style.border   = "1px solid";
document.getElementById("views").appendChild(canvas);

//Deletes everything from the canvas
function clearCanvas() {
    const canvas = document.getElementById('CursorLayer');
    const context = canvas.getContext('2d');
    context.clearRect(0, 0, canvas.width, canvas.height);
}

// Attach an event listener to the button
const computeButton = document.getElementById('compute-button');
computeButton.addEventListener('click', () => {
    clearCanvas();
    initialGuess = computeLinesFitness(measurements, initialGuess);
    printResults(initialGuess);
});


//Create the buttons that the user can click
const compute1kButton = document.getElementById('compute-1k-button');
compute1kButton.addEventListener('click', () => {
    for(let i = 0; i < 1000; i++){
        clearCanvas();
        initialGuess = computeLinesFitness(measurements, initialGuess);
        console.log("Fitness: " + 1/initialGuess.fitness);
    }
    printResults(initialGuess);
});

const compute10kButton = document.getElementById('compute-10k-button');
compute10kButton.addEventListener('click', () => {
    for(let i = 0; i < 10000; i++){
        clearCanvas();
        initialGuess = computeLinesFitness(measurements, initialGuess);
        console.log("Fitness: " + 1/initialGuess.fitness);
    }
    printResults(initialGuess);
});


const computeEndButton = document.getElementById('compute-end-button');
computeEndButton.addEventListener('click', () => {
    //measure time to compute
    var t0 = performance.now();
    var result = findMaxFitness(initialGuess, measurements);
    var t1 = performance.now();
    console.log("Call to findMaxFitness took " + (t1 - t0)/1000 + " seconds.");
    printResults(result);
    treshold = 1.0
    //then we leave all the measurements with fitness less than treshold and run findMaxFitness again
    var newMeasurements = [];
    measurements.forEach(measurement => {
        const {fitness, lines} = magneticallyAttractedLinesFitness(measurement, result);
        if (fitness < treshold) {
            newMeasurements.push(measurement);
        }
    });
    measurements = newMeasurements;
    initialGuess = result;
    console.log("New measurements: " + measurements.length);
    console.log("New initial guess: " + initialGuess.fitness);
    t0 = performance.now();
    result = findMaxFitness(result, newMeasurements);
    t1 = performance.now();
    printResults(result);
    console.log("Call to findMaxFitness took " + (t1 - t0)/1000 + " seconds.");
   
});




//This is where the program really begins. The above is all function definitions
//The way that the progam works is that we basically guess where the four corners are and then
//check to see how good that guess was. To see how good a guess was we "draw" circles from the four corner points
//with radiuses of the measured distances. If the guess was good then all four circles will intersect at a single point.
//The closer the circles are to intersecting at a single point the better the guess is.

//Once we've figured out how good our guess was we try a different guess. We keep the good guesses and throw away the bad guesses
//using a genetic algorithm

//Establish initial guesses for the corners
var initialGuess = {
    // tl: {x: 0, y: initialHeight},
    // tr: {x: initialWidth, y: initialHeight},
    // bl: {x: 0, y: 0},
    // br: {x: initialWidth, y: 0},
    tl: {x: 0, y: initialHeight},
    tr: {x: initialWidth, y: initialHeight},
    bl: {x: 0, y: 0},
    br: {x: initialWidth, y: 0},
    fitness: 0
}



const centerX = initialWidth/2;
const centerY = initialHeight/2;

//calculateTensions(centerX, centerY, initialGuess);


//Un-comment this code to use the simulated measurements

// const randomMeasurementError = 6;
// const constantMeasurementError = 3;
// var measurements = [];
// measurements.push(takeSimulatedMeasurement(centerX,centerY,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX-800,centerY + 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX-800,centerY,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX-800,centerY - 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX,centerY + 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX,centerY - 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX + 800,centerY + 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX + 800,centerY,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX + 800,centerY - 400,randomMeasurementError, constantMeasurementError));



var measurements = [

{bl:1674.53,   br:2755.72,   tr:2389.39,   tl:963.97},
{bl:1563.13,   br:2690.57,   tr:2426.09,   tl:1048.15},
{bl:1452.95,   br:2626.01,   tr:2467.89,   tl:1142.66},
{bl:1365.18,   br:2578.89,   tr:2505.32,   tl:1221.34},
{bl:1281.15,   br:2535.63,   tr:2546.29,   tl:1303.48},
{bl:1200.70,   br:2497.24,   tr:2590.05,   tl:1387.17},
{bl:1122.95,   br:2462.94,   tr:2637.20,   tl:1473.35},
{bl:1050.73,   br:2427.95,   tr:2687.51,   tl:1561.14},
{bl:979.52,   br:2400.45,   tr:2740.27,   tl:1650.05},
{bl:916.51,   br:2375.43,   tr:2795.74,   tl:1740.52},
{bl:1749.04,   br:2627.44,   tr:2235.48,   tl:1086.03},
{bl:1642.66,   br:2557.25,   tr:2275.05,   tl:1162.80},
{bl:1539.36,   br:2490.96,   tr:2319.37,   tl:1248.07},
{bl:1457.86,   br:2441.59,   tr:2359.26,   tl:1320.10},
{bl:1379.39,   br:2393.67,   tr:2402.77,   tl:1396.28},
{bl:1304.53,   br:2355.49,   tr:2449.11,   tl:1474.89},
{bl:1234.06,   br:2315.70,   tr:2499.06,   tl:1556.64},
{bl:1166.54,   br:2279.17,   tr:2551.91,   tl:1639.52},
{bl:1104.80,   br:2249.08,   tr:2607.46,   tl:1725.02},
{bl:1047.34,   br:2222.96,   tr:2665.41,   tl:1811.56},
{bl:1839.32,   br:2502.67,   tr:2082.31,   tl:1217.13},
{bl:1736.85,   br:2425.87,   tr:2124.78,   tl:1286.65},
{bl:1638.09,   br:2357.94,   tr:2172.60,   tl:1363.82},
{bl:1561.56,   br:2304.54,   tr:2214.94,   tl:1430.38},
{bl:1487.87,   br:2255.69,   tr:2261.33,   tl:1500.98},
{bl:1418.30,   br:2211.88,   tr:2310.67,   tl:1574.31},
{bl:1352.28,   br:2170.53,   tr:2363.65,   tl:1650.63},
{bl:1291.68,   br:2131.76,   tr:2419.30,   tl:1729.63},
{bl:1235.05,   br:2100.75,   tr:2477.71,   tl:1810.73},
{bl:1183.96,   br:2072.37,   tr:2538.80,   tl:1893.05},
{bl:1932.51,   br:2379.39,   tr:1931.76,   tl:1355.37},
{bl:1837.16,   br:2301.33,   tr:1976.24,   tl:1417.05},
{bl:1744.46,   br:2226.75,   tr:2027.75,   tl:1487.81},
{bl:1673.06,   br:2170.98,   tr:2073.33,   tl:1549.27},
{bl:1604.69,   br:2118.61,   tr:2122.56,   tl:1614.63},
{bl:1539.76,   br:2070.24,   tr:2175.11,   tl:1683.10},
{bl:1479.23,   br:2027.29,   tr:2231.19,   tl:1754.97},
{bl:1423.96,   br:1988.25,   tr:2290.02,   tl:1828.96},
{bl:1373.34,   br:1950.95,   tr:2351.90,   tl:1905.56},
{bl:1326.59,   br:1919.77,   tr:2416.26,   tl:1984.60},
{bl:2036.53,   br:2261.27,   tr:1781.54,   tl:1496.74},
{bl:1944.43,   br:2176.51,   tr:1830.25,   tl:1554.04},
{bl:1856.13,   br:2098.77,   tr:1885.54,   tl:1618.34},
{bl:1789.72,   br:2037.85,   tr:1934.63,   tl:1674.58},
{bl:1725.92,   br:1984.61,   tr:1986.99,   tl:1735.35},
{bl:1666.17,   br:1933.11,   tr:2043.26,   tl:1799.75},
{bl:1609.90,   br:1886.03,   tr:2102.64,   tl:1866.66},
{bl:1558.94,   br:1844.06,   tr:2165.32,   tl:1936.57},
{bl:1512.42,   br:1805.39,   tr:2230.41,   tl:2009.50},
{bl:1472.89,   br:1769.87,   tr:2297.98,   tl:2084.35},
{bl:2144.51,   br:2143.16,   tr:1633.99,   tl:1642.40},
{bl:2057.75,   br:2059.68,   tr:1685.58,   tl:1694.06},
{bl:1979.23,   br:1975.58,   tr:1744.56,   tl:1753.88},
{bl:1913.65,   br:1911.09,   tr:1797.82,   tl:1806.93},
{bl:1855.46,   br:1853.03,   tr:1854.38,   tl:1863.45},
{bl:1801.13,   br:1797.12,   tr:1914.40,   tl:1923.15},
{bl:1748.80,   br:1745.50,   tr:1977.62,   tl:1986.48},
{bl:1699.81,   br:1700.05,   tr:2043.77,   tl:2052.48},
{bl:1656.95,   br:1659.33,   tr:2112.68,   tl:2121.21},
{bl:1619.38,   br:1621.95,   tr:2184.03,   tl:2192.15},
{bl:2259.96,   br:2035.39,   tr:1488.43,   tl:1790.05},
{bl:2179.14,   br:1944.65,   tr:1543.45,   tl:1838.55},
{bl:2099.33,   br:1856.72,   tr:1609.94,   tl:1894.36},
{bl:2040.92,   br:1791.16,   tr:1666.23,   tl:1942.55},
{bl:1984.56,   br:1727.40,   tr:1727.31,   tl:1994.96},
{bl:1932.35,   br:1667.45,   tr:1791.47,   tl:2050.98},
{bl:1886.92,   br:1611.80,   tr:1858.87,   tl:2110.09},
{bl:1844.83,   br:1558.48,   tr:1929.38,   tl:2172.50},
{bl:1806.01,   br:1513.35,   tr:2002.21,   tl:2237.39},
{bl:1772.84,   br:1470.46,   tr:2077.07,   tl:2304.91},
{bl:2379.92,   br:1935.19,   tr:1347.09,   tl:1939.84},
{bl:2304.51,   br:1838.40,   tr:1406.29,   tl:1984.92},
{bl:2227.30,   br:1744.46,   tr:1478.73,   tl:2035.76},
{bl:2173.20,   br:1672.63,   tr:1540.01,   tl:2080.99},
{bl:2120.45,   br:1603.80,   tr:1606.24,   tl:2130.19},
{bl:2072.94,   br:1539.41,   tr:1675.09,   tl:2182.64},
{bl:2028.14,   br:1478.90,   tr:1747.13,   tl:2238.50},
{bl:1989.41,   br:1422.21,   tr:1821.82,   tl:2297.04},
{bl:1953.72,   br:1372.53,   tr:1898.53,   tl:2358.61},
{bl:1921.32,   br:1328.31,   tr:1977.70,   tl:2422.93},
{bl:2504.98,   br:1838.50,   tr:1208.61,   tl:2091.19},
{bl:2431.39,   br:1739.16,   tr:1275.01,   tl:2132.95},
{bl:2359.88,   br:1638.28,   tr:1354.37,   tl:2180.21},
{bl:2307.69,   br:1561.75,   tr:1421.10,   tl:2222.62},
{bl:2258.68,   br:1488.09,   tr:1492.11,   tl:2268.67},
{bl:2213.67,   br:1417.61,   tr:1566.32,   tl:2318.02},
{bl:2170.14,   br:1355.01,   tr:1643.02,   tl:2370.74},
{bl:2135.29,   br:1293.65,   tr:1722.12,   tl:2426.00},
{bl:2102.22,   br:1237.69,   tr:1803.30,   tl:2484.39},
{bl:2072.36,   br:1188.40,   tr:1886.35,   tl:2545.56},
{bl:2631.96,   br:1757.09,   tr:1074.68,   tl:2243.64},
{bl:2560.29,   br:1646.89,   tr:1152.50,   tl:2282.59},
{bl:2495.49,   br:1542.90,   tr:1237.80,   tl:2326.96},
{bl:2444.41,   br:1460.87,   tr:1310.86,   tl:2366.89},
{bl:2397.70,   br:1382.03,   tr:1387.63,   tl:2409.75},
{bl:2355.83,   br:1306.78,   tr:1466.90,   tl:2456.50},
{bl:2317.92,   br:1235.91,   tr:1548.29,   tl:2505.98},
{bl:2281.96,   br:1169.28,   tr:1632.32,   tl:2558.78},
{bl:2250.53,   br:1107.51,   tr:1717.74,   tl:2613.91},
{bl:2225.05,   br:1050.80,   tr:1804.65,   tl:2672.04},
{bl:2761.38,   br:1678.17,   tr:952.29,   tl:2397.26},
{bl:2691.08,   br:1566.54,   tr:1037.67,   tl:2433.38},
{bl:2630.15,   br:1455.75,   tr:1131.59,   tl:2475.24},
{bl:2581.92,   br:1369.61,   tr:1212.32,   tl:2512.67},
{bl:2540.56,   br:1285.89,   tr:1293.66,   tl:2553.27},
{bl:2499.79,   br:1206.01,   tr:1378.75,   tl:2597.10},
{bl:2464.10,   br:1126.63,   tr:1465.55,   tl:2644.47},
{bl:2430.49,   br:1053.46,   tr:1553.76,   tl:2694.12},
{bl:2400.33,   br:985.46,   tr:1643.45,   tl:2746.73},
{bl:2376.69,   br:923.40,   tr:1733.87,   tl:2801.87},

];

//Do projection and scaling
//measurements = scaleMeasurements(measurements, 0.9945);

//measurements = projectMeasurements(measurements);


//const stretch_guess = 0.01;
//const stretch_guess = 0.001;
const stretch_guess = 0.03;
computeLinesFitness(measurements, initialGuess);

measurements = scaleMeasurementsBasedOnTension(measurements,stretch_guess);
measurements = projectMeasurements(measurements);



</script>

</body>
</html>